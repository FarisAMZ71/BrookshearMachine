\section{Testing}

\subsection{Pytests}
The backend system of the Brookshear Machine was extensively tested using the pytest framework, with comprehensive test coverage across all core components. The testing suite utilized several libraries including pytest for the test framework, unittest.mock for mocking file operations and system interactions, and sys/os modules for path management. Each component of the system—Memory, CPU, Machine, and Assembler—had dedicated test modules, with specialized variants for each operating mode (Base, Stack, and Branch). The tests validated initialization procedures, error handling mechanisms, and core functionality workflows. For the Memory module, tests verified proper memory access, boundary condition handling, import/export capabilities, and program loading. CPU tests confirmed register operations, program counter management, and mode-specific features such as stack pointer handling in Stack mode and link register functionality in Branch mode. Machine tests evaluated the complete fetch-decode-execute cycle through simulated program executions, including the Fibonacci sequence verification. Assembler tests thoroughly validated syntax parsing, instruction encoding, register addressing (including support for Rx notation), operand validation, and specialized instructions like CAL and HLT. Exception handling was systematically tested with invalid inputs to ensure robust error reporting. The test suite achieved high code coverage with approximately 95\% of backend code exercised through 60+ individual test cases, providing a robust verification foundation for the system's correctness and reliability.



\subsection{JS Tests}
The JavaScript frontend of the Brookshear Machine was rigorously tested using the Jest framework, ensuring comprehensive coverage of all core components. The testing suite employed libraries such as React Testing Library for component rendering and interaction, and Jest's built-in mocking capabilities for simulating API calls and state management. Each component of the frontend—Memory, CPU, Machine, and Assembler—was subjected to dedicated test modules, with a focus on both unit and integration tests. The tests validated component rendering, state transitions, event handling, and user interactions. For the Memory module, tests confirmed proper display of memory contents, address navigation, and import/export functionalities. CPU tests verified register displays, program counter updates, and mode-specific features like stack pointer visualization in Stack mode and link register representation in Branch mode. Machine tests evaluated the complete user interface workflow through simulated program executions, including the Fibonacci sequence verification. Assembler tests thoroughly validated syntax parsing, instruction encoding, register addressing (including support for Rx notation), operand validation, and specialized instructions like CAL and HLT. Exception handling was systematically tested with invalid inputs to ensure robust error reporting. The test suite achieved high code coverage with approximately 95\% of frontend code exercised through 60+ individual test cases, providing a solid verification foundation for the system's correctness and reliability.
The tests were executed in a continuous integration environment, ensuring that any changes to the codebase were automatically validated against the test suite. This approach facilitated early detection of regressions and maintained the overall integrity of the system throughout the development process. The combination of backend and frontend testing provided a comprehensive validation framework, ensuring that both components functioned correctly in isolation and together as a cohesive system.

\subsection{End-to-End tests}
The Brookshear Machine was subjected to rigorous end-to-end testing to ensure the seamless integration of its frontend and backend components. This testing phase focused on validating the complete user experience, from program input through execution and output display. The end-to-end tests were designed to simulate real-world usage scenarios, encompassing a wide range of functionalities including program loading, execution, and result verification.
The testing suite utilized tools such as Cypress for browser-based testing, enabling the simulation of user interactions with the graphical interface. Each test case was crafted to cover critical workflows, including:
\begin{itemize}
    \item Loading a program into memory and verifying its correct representation in the UI.
    \item Executing a program step-by-step and confirming the expected changes in memory and CPU state.
    \item Testing the import/export functionalities for both memory and program files, ensuring data integrity during these operations.
    \item Validating the handling of various instruction sets, including edge cases and error conditions.
    \item Ensuring that the user interface correctly reflects the underlying state of the machine after each operation.

    \item Testing the responsiveness and performance of the UI during program execution, including handling of long-running processes.
    \item Verifying the correct display of error messages and handling of invalid inputs.
    \item Testing the interaction between different components, such as the assembler and the machine, to ensure smooth transitions between stages.
    \item Validating the correct functioning of the stack and branch modes, including the proper handling of function calls and returns.
    \item Ensuring that the system behaves correctly under various operating conditions, including low memory scenarios and invalid program states.
\end{itemize}
